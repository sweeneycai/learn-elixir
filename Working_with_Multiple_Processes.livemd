<!-- livebook:{"persist_outputs":true} -->

# Working with Multiple Processes

## Handling Multiple Messages

一个最简单的线程间通信的案例

```elixir
defmodule Spawn do
  def greet do
    receive do
      {sender, msg} ->
        send(sender, {:ok, "Hello, #{msg}"})
    end
  end
end

pid = spawn(Spawn, :greet, [])
send(pid, {self(), "world!"})

receive do
  {:ok, msg} ->
    IO.puts(msg)
end
```

<!-- livebook:{"output":true} -->

```
Hello, world!
```

<!-- livebook:{"output":true} -->

```
:ok
```

对于上面的例子，我们接着向 `Spawn` 发送消息，看看会发生什么？

```elixir
send(pid, {self(), "world!"})

receive do
  {:ok, msg} ->
    IO.puts(msg)
after
  500 ->
    IO.puts("Session closed")
end
```

<!-- livebook:{"output":true} -->

```
Session closed
```

<!-- livebook:{"output":true} -->

```
:ok
```

可以看到上面的 *cell* halt 住了，这是因为上面定义的 `greet` 函数只能处理一条消息，如果要处理多条消息，需要使用递归。

```elixir
defmodule Spawn2 do
  def greet do
    receive do
      {sender, msg} ->
        send(sender, {:ok, "Hello, #{msg}"})
        greet()
    end
  end
end

pid = spawn(Spawn2, :greet, [])

send(pid, {self(), "world1"})

receive do
  {:ok, msg} ->
    IO.puts(msg)
after
  500 ->
    IO.puts("Connection closed")
end

send(pid, {self(), "world2"})

receive do
  {:ok, msg} ->
    IO.puts(msg)
after
  500 ->
    IO.puts("Connection closed")
end
```

<!-- livebook:{"output":true} -->

```
Hello, world1
Hello, world2
```

<!-- livebook:{"output":true} -->

```
:ok
```

### Recursion and the Stack

```elixir
defmodule TailRecursive do
  def factorial(n), do: _factorial(n, 1)
  def _factorial(0, acc), do: acc
  def _factorial(n, acc), do: _factorial(n - 1, n * acc)
end
```

<!-- livebook:{"output":true} -->

```
{:module, TailRecursive, <<70, 79, 82, 49, 0, 0, 7, ...>>, {:_factorial, 2}}
```

```elixir
TailRecursive.factorial(90)
```

<!-- livebook:{"output":true} -->

```
1485715964481761497309522733620825737885569961284688766942216863704985393094065876545992131370884059645617234469978112000000000000000000000
```

### Process Overhead

```elixir
defmodule Chain do
  # 要在子线程中执行的函数
  def counter(next_pid) do
    receive do
      n ->
        send(next_pid, n + 1)
    end
  end

  def create_processes(n) do
    # 创建一个新线程，并给新线程发送自己的PID
    code_to_run = fn _, send_to ->
      spawn(Chain, :counter, [send_to])
    end

    # 等价于 `fn n, acc -> code_to_run(n, acc)`
    last = Enum.reduce(1..n, self(), code_to_run)

    send(last, 0)

    receive do
      final_answer when is_integer(final_answer) ->
        "Result is #{inspect(final_answer)}"
    end
  end

  def run(n) do
    :timer.tc(Chain, :create_processes, [n])
    |> IO.inspect(lable: "processes")
  end
end
```

<!-- livebook:{"output":true} -->

```
{:module, Chain, <<70, 79, 82, 49, 0, 0, 11, ...>>, {:run, 1}}
```

```elixir
Chain.run(10)
```

<!-- livebook:{"output":true} -->

```
{0, "Result is 10"}
```

<!-- livebook:{"output":true} -->

```
{0, "Result is 10"}
```

```elixir
Chain.run(100)
```

<!-- livebook:{"output":true} -->

```
{307, "Result is 100"}
```

<!-- livebook:{"output":true} -->

```
{307, "Result is 100"}
```

```elixir
Chain.run(1000)
```

<!-- livebook:{"output":true} -->

```
{6553, "Result is 1000"}
```

<!-- livebook:{"output":true} -->

```
{6553, "Result is 1000"}
```

```elixir
Chain.run(10000)
```

<!-- livebook:{"output":true} -->

```
{62361, "Result is 10000"}
```

<!-- livebook:{"output":true} -->

```
{62361, "Result is 10000"}
```

```elixir
Chain.run(40000)
```

<!-- livebook:{"output":true} -->

```
{228044, "Result is 40000"}
```

<!-- livebook:{"output":true} -->

```
{228044, "Result is 40000"}
```

```elixir
# 线程数超阈值报警
# Chain.run(4000000)
```

<!-- livebook:{"output":true} -->

```
nil
```

### When Processes Die

```elixir
defmodule Link1 do
  # 使用 erlang 的系统库
  import :timer, only: [sleep: 1]

  def sad_function do
    sleep(500)
    exit(:boom)
  end

  def run do
    spawn(Link1, :sad_function, [])

    receive do
      msg -> IO.puts("MESSAGE RECEIVED: #{inspect(msg)}")
    after
      1000 ->
        IO.puts("Nothing happend")
    end
  end
end

Link1.run()
```

<!-- livebook:{"output":true} -->

```
Nothing happend
```

<!-- livebook:{"output":true} -->

```
:ok
```

```elixir
defmodule Link2 do
  import :timer, only: [sleep: 1]

  def sad_func do
    sleep(500)
    exit(:boom)
  end

  def run do
    spawn_link(Link2, :sad_func, [])

    receive do
      msg -> IO.puts("MESSAGE RECEIVED: #{inspect(msg)}")
    after
      1000 ->
        IO.puts("Nothing happend")
    end
  end
end

# Link2.run()
```

<!-- livebook:{"output":true} -->

```
{:module, Link2, <<70, 79, 82, 49, 0, 0, 8, ...>>, {:run, 0}}
```

上面的例子在 **Livebook** 中会报错: *Evaluation process terminated - :boom*

```elixir
defmodule Link3 do
  import :timer, only: [sleep: 1]

  def sad_func do
    sleep(500)
    exit(:boom)
  end

  def run do
    # C  onvert the exit signals from a linked process 
    # into a message you can handle
    Process.flag(:trap_exit, true)
    spawn_link(Link3, :sad_func, [])

    receive do
      msg ->
        IO.puts("MESSAGE RECEIVED: #{inspect(msg)}")
    after
      1000 ->
        IO.puts("Nothing happend")
    end
  end
end

Link3.run()
```

<!-- livebook:{"output":true} -->

```
MESSAGE RECEIVED: {:EXIT, #PID<0.4187.3>, :boom}
```

<!-- livebook:{"output":true} -->

```
:ok
```

## Monitoring a Process

_Link_ 将两个线程连接起来，调用方和被调用方之间可以互相通信。与之相反，如果一个线程监控另外一个线程，那么只有当被调用方出错异常退出的时候才会通知调用方，消息内容是 `:DOWN`。

<!-- livebook:{"break_markdown":true} -->

`Process.monitor` 和 `spawn_monitor` 都有监控的功能，但是前者不是原子性的，后者是原子性的。

```elixir
defmodule Monitor1 do
  import :timer, only: [sleep: 1]

  def sad_func do
    sleep(500)
    exit(:boom)
  end

  def run do
    spawn_monitor(Monitor1, :sad_func, [])

    receive do
      msg ->
        IO.puts("MESSAGE RECEIVED: #{inspect(msg)}")
    after
      1000 ->
        IO.puts("Nothing happend")
    end
  end
end

Monitor1.run()
```

<!-- livebook:{"output":true} -->

```
MESSAGE RECEIVED: {:DOWN, #Reference<0.610076405.1359216643.194172>, :process, #PID<0.4303.3>, :boom}
```

<!-- livebook:{"output":true} -->

```
:ok
```

那么什么时候使用 _link_ 什么时候使用 _monitor_ 呢？

这主要取决于线程的语义。如果一个线程失败了需要停止另外一个线程，这个时候需要 _link_ 。反之，如果需要知道某些线程失败的原因，使用 _monitor_ 。

## Parallel Map —— The "Hello, World" of Erlang

有趣的事情：一个并行的 `map` 实现。

```elixir
defmodule Parallel do
  def pmap(collection, fun) do
    import :rand, only: [uniform: 1]
    import :timer, only: [sleep: 1]
    # 这里的 me 指代的是主线程，子线程的计算结果都是要返回给主线程的
    me = self()

    collection
    |> Enum.map(fn elem ->
      spawn_link(fn ->
        # 测试返回的顺序
        sleep(uniform(500))
        send(me, {self(), fun.(elem)})
      end)
    end)
    |> Enum.map(fn pid ->
      receive do
        {^pid, result} -> result
      end
    end)
  end
end
```

<!-- livebook:{"output":true} -->

```
{:module, Parallel, <<70, 79, 82, 49, 0, 0, 9, ...>>, {:pmap, 2}}
```

`receive` 里面，如果是 `{ ^pid, result }`，那么返回的值会按照集合最初的顺序进行排序，反之则按照返回值的顺序进行排序。

```elixir
# 按集合顺序排序
1..10
|> Parallel.pmap(&(&1 * &1))
```

<!-- livebook:{"output":true} -->

```
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
```

```elixir
# 按返回顺序排序
1..10
|> Parallel.pmap(&(&1 * &1))
```

<!-- livebook:{"output":true} -->

```
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
```

## A Fibonacci Server

```elixir
defmodule FibSolver do
  def fib(scheduler) do
    send(scheduler, {:ready, self()})

    receive do
      {:fib, n, client} ->
        send(client, {:answer, n, fib_calc(n), self()})
        fib(scheduler)

      {:shutdown} ->
        exit(:normal)
    end
  end

  def fib_calc(0), do: 0
  def fib_calc(1), do: 1
  def fib_calc(n), do: fib_calc(n - 1) + fib_calc(n - 2)
end
```

<!-- livebook:{"output":true} -->

```
{:module, FibSolver, <<70, 79, 82, 49, 0, 0, 9, ...>>, {:fib_calc, 1}}
```

### The Task Scheduler

```elixir

```

```elixir

```
