<!-- livebook:{"persist_outputs":true} -->

# MacrosAndCodeEvaluation

## Section

> Never use a macro when you could use a function.

## Implementing an if Statement



```elixir
defmodule My do
  def myif(condition, clause) do
    do_clause = Keyword.get(clause, :do)
    else_clause = Keyword.get(clause, :else)

    case condition do
      val when val in [false, nil] ->
        else_clause

      _otherwise ->
        do_clause
    end
  end
end

My.myif(1 == 2, do: IO.puts("1==2"), else: IO.puts("1<>2"))
```

<!-- livebook:{"output":true} -->

```
1==2
1<>2
```

<!-- livebook:{"output":true} -->

```
:ok
```

> When we call the myif function, Elixir has to evaluate all of its parameters
> before passing them in. So both the do: and else: clauses are evaluated, and
> we see their output.

Because `IO.puts` returns `:ok` on success, what actually get passed to `myif` is:

`myif 1 == 2, do: :ok, else: :ok`

So we need a way of delaying the execution of these clauses, and this is where macros come in.

## Macros Inject Code


